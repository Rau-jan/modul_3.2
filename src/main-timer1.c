/**
 * Пример для Arduino Nano.
 *
 * 16-битный Таймер-счетчик с PWM (Timer/Counter1)
 * Используется для прямого или обратного счета времени.
 * Представляет собой ячейку памяти хранящую 65536 значений (0 - 65535).
 * Через определенный промежуток времени таймер увеличивает значение в ячейке памяти.
 * При переполнении таймер автоматически обнуляется.
 * Частота работы микроконтроллера f = 16 MHz = 16 000 000 Hz
 *
 * T = 1/f; (время работы таймера без делителя)
 * T = 1 / 16 000 000 = 0.0000000625 s = 0.0625 us
 * T(65535) = 0.0625 us * 65535 = 4095.93 us = 4.09 ms (время работы таймера до переполнения)
 *
 * Период делителя = 1 / (Частота счетчика / Делитель)
 * T = 1 / (16 000 000 / 8) = 0.5 us; T(65535) = 32 767.5 us = 32.76 ms;
 * T = 1 / (16 000 000 / 64) = 4 us; T(65535) = 262 140 us = 262.14 ms;
 * T = 1 / (16 000 000 / 256) = 16 us; T(65535) = 1 048 560 us = 1 048.56 ms = 1.04 s;
 * T = 1 / (16 000 000 / 1024) = 64 us; T(65535) = 4 194 240 us = 4 194.24 ms = 4.19 s;
 */

#include <avr/io.h>
#include <stdbool.h>
#include "bitwise.h"

#define LED_PIN 5 // PB5(D13)

int main(void)
{
    set_bit(DDRB, LED_PIN); // Настройка PB5 на выход

    // Настройка делителя (TCCR1B - Timer/Counter1 Control Register B)
    // Задаем prescaler = 256
    set_bit(TCCR1B, CS12);
    clear_bit(TCCR1B, CS11);
    clear_bit(TCCR1B, CS10);

    // TCNT1H and TCNT1L - Timer/Counter1
    // Поскольку ATmega328P 8 битный, а таймер-счетчик 16 битный,
    // то для хранения значения счетчика используется два регистра (TCNT1H and TCNT1L), но мы можем использовать просто TCNT1.
    TCNT1 = 0; // Обнуляем значение таймера (0-65535)

    bool is_blocked = false;

    while (1)
    {
        // Когда таймер достигнет значения 62500, пройдет примерно 1000 ms (16 us * 62500 = 1000 us = 1 000 ms = 1 s)
        // Без использования блокировки светодиод будет мигать чуть быстрее чем 1 секунда,
        // это связано с тем что цикл while может сделать несколько проходов прежде чем таймер-счетчик сменит свое значение.
        if (TCNT1 == 62500 && !is_blocked)
        {
            invert_bit(PORTB, LED_PIN); // Включить/Выключить LED
            is_blocked = true;
        }
        else
        {
            is_blocked = false;
        }
    }
}